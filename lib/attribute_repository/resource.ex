defmodule AttributeRepository.Resource do
  @moduledoc """
  Convenience macro to create resource module that makes it fancier to use an
  attribute repository

  ## Usage

  Create a module that uses this module:

  ```elixir
  defmodule Asteroid.Subject do
    use AttributeRepository.Resource, otp_app: :asteroid
  end
  ```

  It expects one option: `otp_app` used to retrieve configuration.

  ## Example

  ```elixir
  iex(13)> alias Asteroid.Subject
  Asteroid.Subject

  iex> {:ok, s} = Subject.load("uid=john,ou=People,dc=example,dc=org")
  {:ok,
   %Asteroid.Subject{
     attrs: %{
       "cn" => ["John Doe"],
       "displayName" => "John Doe",
       "givenName" => ["John"],
       "mail" => ["john.doe@example.com"],
       "manager" => ["uid=toto,ou=People,dc=example,dc=org"],
       "sn" => ["Doe"]
     },
     id: "uid=john,ou=People,dc=example,dc=org",
     modifications: [],
     newly_created: false
   }}
  iex> s = s
  ...> |> Subject.add("initials", "JD")
  ...> |> Subject.add("mail", "john.doe@example.org")
  ...> |> Subject.remove("manager")
  %Asteroid.Subject{
    attrs: %{
      "cn" => ["John Doe"],
      "displayName" => "John Doe",
      "givenName" => ["John"],
      "initials" => "JD",
      "mail" => ["john.doe@example.org", "john.doe@example.com"],
      "sn" => ["Doe"]
    },
    id: "uid=john,ou=People,dc=example,dc=org",
    modifications: [
      {:add, "initials", "JD"},
      {:add, "mail", "john.doe@example.org"},
      {:delete, "manager"}
    ],
    newly_created: false
  }
  iex> Subject.store(s)
  :ok
  ```

  ## Configuration

  Configuration is retrieved by the `config/1` function which requests the configuration by
  calling:

  ```elixir
  Application.get_env(otp_app, :attribute_repositories)[instance]
  ```

  where :
  - `otp_app` is the option passed to the module
  - `instance` is the lowercased atom of the last item of the `Module.split/1` call of the
  module. For example, the `instance` for `MyApp.Resource.User` is `:user`

  The `config/1` function is overridable.

  ## Generating ids

  The `id()` is generated by `gen_new_id/1` using the following implementation:

  ```elixir
  def gen_new_id(_gen_new_opts) do
    16
    |> :crypto.strong_rand_bytes()
    |> Base.url_encode64(padding: false)
  end
  ```

  16 bytes of randomness is the same as for UUIDv4.

  This function is overridable in case one need different identifiers:
  - prefixing / suffixing
  - generating LDAP DNs
  - etc.

  Example:

  ```elixir
  defmodule Asteroid.Subject do
    use AttributeRepository.Resource, otp_app: :asteroid

    def gen_new_id(opts) do
      "sub-" <> super(opts)
    end
  end
  ```

  will generate:

  ```elixir
  iex> Asteroid.Subject.gen_new()
  %Asteroid.Subject{
    attrs: %{},
    id: "sub-PhXdYtqDHuBxNcIfog7J1w",
    modifications: [],
    newly_created: true
  }
  ```
  """

  defmodule NotUniqueAttributeError do
    @moduledoc """
    Error returned when a search on a attribute that should be unique returns more than one
    result, i.e. the attribute is actually not unique
    """

    defexception message: "Attribute is not unique"
  end

  @type config :: Keyword.t()

  defmacro __using__(opts) do
    quote location: :keep, bind_quoted: [opts: opts] do
      additional_doc = """
      ## Functions

      There are two types of functions:
      - those interacting with the backend attribute repository:
        - `load/2`
        - `load_from_unique_attribute/3`
        - `store/2`
        - `delete/2`
      - those for manipulating the #{__MODULE__}.t() resource:
        - `gen_new/1`
        - `gen_new_id/1`
        - `add/3`
        - `remove/3`
      """

      {line_number, existing_moduledoc} =
        Module.delete_attribute(__MODULE__, :moduledoc) || {0, ""}

      Module.put_attribute(
        __MODULE__,
        :moduledoc,
        {line_number, existing_moduledoc <> additional_doc})

      @enforce_keys [:id]

      defstruct id: "", attrs: %{}, modifications: [], newly_created: false

      @type id :: String.t()

      @type t :: %__MODULE__{
        id: id(),
        attrs: AttributeRepository.resource(),
        modifications: [AttributeRepository.Write.modify_op()],
        newly_created: boolean()
      }

      @doc """
      Add a value to a `#{__MODULE__}.t()`

      ## Rules
      - If the attribute already exists:
        - if the attribute is a list: add the new value to the list
        - otherwise set or replace the value of the target attribute

      Note that if you want to make a new attribute multi-valued, you shall add a list as
      its first value (be it a list with only one element).
      """

      @spec add(t(),
                AttributeRepository.attribute_name(),
                AttributeRepository.attribute_value()) :: t()

      def add(%__MODULE__{attrs: attrs} = resource, attribute_name, attribute_value) do
        new_value =
          case attrs[attribute_name] do
            nil ->
              attribute_value

            [_ | _] = list ->
              [attribute_value] ++ list

            _ ->
              attribute_value
          end

        %{resource |
          attrs: Map.put(resource.attrs, attribute_name, new_value),
          modifications: resource.modifications ++ [{:add, attribute_name, attribute_value}]
        }
      end

      @doc """
      Removes a value from a `#{__MODULE__}.t()`

      This functions behaves differently depending on its 3rd argument:
      - `:no_value`: the attribute is simply removed
      - Otherwise:
        - if the attribute is a list, removes all the occurrences of the attribute value from
        the list
        - otherwise doesn't do anything and returns the `#{__MODULE__}.t()` as-is
      """

      @spec remove(t(),
                   AttributeRepository.attribute_name(),
                   AttributeRepository.attribute_value() | :no_value) :: t()

      def remove(resource, attribute_name, value \\ :no_value)

      def remove(resource, attribute_name, :no_value) do
        %{resource |
          attrs: Map.delete(resource.attrs, attribute_name),
          modifications: resource.modifications ++ [{:delete, attribute_name}]
        }
      end

      def remove(%__MODULE__{attrs: attrs} = resource, attribute_name, attribute_value) do
        case attrs[attribute_name] do
          [_ | _] = list ->
            new_value = Enum.filter(list, fn elt -> elt != attribute_value end)

            %{resource |
              attrs: Map.put(attrs, attribute_name, new_value),
              modifications: resource.modifications ++ [{:delete, attribute_name, attribute_value}]
            }

          _ ->
            resource
        end
      end

      @doc """
      Generates a new `#{__MODULE__}.t()`

      Uses `gen_new_id/1` to generate the identifier.
      ```
      """

      @spec gen_new(Keyword.t()) :: t()

      def gen_new(gen_new_opts \\ []) do
        %__MODULE__{
          id: gen_new_id(gen_new_opts),
          newly_created: true
        }
      end

      @doc """
      Generates a new id
      """

      @spec gen_new_id(Keyword.t()) :: t()

      def gen_new_id(_gen_new_opts) do
        16
        |> :crypto.strong_rand_bytes()
        |> Base.url_encode64(padding: false)
      end

      defoverridable gen_new_id: 1

      @doc """
      Loads a resource given its id

      ## Example
      ```elixir
      iex> Asteroid.Subject.load("uid=john,ou=People,dc=example,dc=org")
      {:ok,
       %Asteroid.Subject{
         attrs: %{
           "cn" => ["John Doe"],
           "displayName" => "John Doe",
           "gecos" => "John Doe",
           "gidNumber" => 5000,
           "givenName" => ["John"],
           "homeDirectory" => "/home/john",
           "loginShell" => "/bin/bash",
           "mail" => ["john.doe@example.com"],
           "manager" => ["uid=toto,ou=People,dc=example,dc=org"],
           "objectClass" => ["inetOrgPerson", "posixAccount", "shadowAccount"],
           "sn" => ["Doe"],
           "uid" => ["john"],
           "uidNumber" => 10000
         },
         id: "uid=john,ou=People,dc=example,dc=org"
       }}
      ```
      """

      @spec load(AttributeRepository.id(), Keyword.t()) ::
      {:ok, t()}
      | {:error, %AttributeRepository.ReadError{}}
      | {:error, %AttributeRepository.Read.NotFoundError{}}

      def load(resource_id, load_opts \\ []) do
        attribute_repository_conf = config(context: load_opts[:context])

        case attribute_repository_conf[:module].get(
          resource_id,
          attribute_repository_conf[:default_loaded_attributes] || :all,
          attribute_repository_conf[:run_opts]
        ) do
          {:ok, resource} ->
            {:ok, %__MODULE__{id: resource_id, attrs: resource}}

          {:error, _} = error ->
            error
        end
      end

      @doc """
      Loads a resource given one of its attributes

      Note that:
      - the configured module must support the search behaviour (`AttributeRepository.Search`)
      - the attribute value must be unique (otherwise
      `{:error, %AttributeRepository.Resource.NotUniqueAttributeError{}})` error will be returned

      ## Example
      ```elixir
      iex> Asteroid.Subject.load_from_unique_attribute("mail", "john.doe@example.com")
      {:ok,
       %Asteroid.Subject{
         attrs: %{
           "cn" => ["John Doe"],
           "displayName" => "John Doe",
           "gecos" => "John Doe",
           "gidNumber" => 5000,
           "givenName" => ["John"],
           "homeDirectory" => "/home/john",
           "loginShell" => "/bin/bash",
           "mail" => ["john.doe@example.com"],
           "manager" => ["uid=toto,ou=People,dc=example,dc=org"],
           "objectClass" => ["inetOrgPerson", "posixAccount", "shadowAccount"],
           "sn" => ["Doe"],
           "uid" => ["john"],
           "uidNumber" => 10000
         },
         id: "uid=john,ou=People,dc=example,dc=org"
       }}

      iex> Asteroid.Subject.load_from_unique_attribute("sn", "Doe")
      {:error,
       %AttributeRepository.Resource.NotUniqueAttributeError{
         message: "Multiple entries returned"
       }}
      ```
      """

      @spec load_from_unique_attribute(AttributeRepository.attribute_name(),
                                       AttributeRepository.attribute_value,
                                       Keyword.t()) ::
      {:ok, t()}
      | {:error, %AttributeRepository.ReadError{}}
      | {:error, %AttributeRepository.Read.NotFoundError{}}
      | {:error, %AttributeRepository.UnsupportedError{}}
      | {:error, %AttributeRepository.Resource.NotUniqueAttributeError{}}

      def  load_from_unique_attribute(attribute_name, attribute_value, load_opts \\ []) do
        attribute_repository_conf = config(context: load_opts[:context])

        # generated by AttributeRepository.Search.Filter.parse/1
        filter = {:attrExp,
          {:eq,
            %AttributeRepository.Search.AttributePath{
              attribute: attribute_name,
              sub_attribute: nil,
              uri: nil
            }, attribute_value}}

        case attribute_repository_conf[:module].search(
          filter,
          attribute_repository_conf[:default_loaded_attributes] || :all,
          attribute_repository_conf[:run_opts]
        ) do
          {:ok, []} ->
            {:error, AttributeRepository.Read.NotFoundError.exception("Entry not found")}

          {:ok, [{resource_id, resource}]} ->
            {:ok, %__MODULE__{id: resource_id, attrs: resource}}

          {:ok, _} ->
            {:error, AttributeRepository.Resource.NotUniqueAttributeError.exception(
              "Multiple entries returned")}

          {:error, _} = error ->
            error
        end
      end

      @doc """
      Persists a `#{__MODULE__}.t()` in the attribute store

      The attribute store must support the write behaviour (`AttributeRepository`)

      Unless the `#{__MODULE__}.t()` has been newly generated (using `#{__MODULE__}.gen_new()/1`),
      this function will first try to modify the resource first (using the
      `c:AttributeRepository.modify/3` callback) and only then, the resource doesn't exist, it
      attempts to create it (using the `c:AttributeRepository.put/3` callback).
      """

      @spec store(t(), Keyword.t()) ::
      :ok
      | {:error, %AttributeRepository.WriteError{}}
      | {:error, %AttributeRepository.ReadError{}}
      | {:error, %AttributeRepository.UnsupportedError{}}

      def store(resource, store_opts \\ [])

      def store(%__MODULE__{newly_created: false} = resource, store_opts) do
        attribute_repository_conf = config(context: store_opts[:context])

        case attribute_repository_conf[:module].modify(
          resource.id,
          resource.modifications,
          attribute_repository_conf[:run_opts]
        ) do
          :ok ->
            :ok

          {:error, %AttributeRepository.Read.NotFoundError{}} ->
            attribute_repository_conf[:module].put(
              resource.id,
              resource.attrs,
              attribute_repository_conf[:run_opts]
            )

          {:error, _} = error ->
            error
        end
      end

      def store(%__MODULE__{newly_created: true} = resource, store_opts) do
        attribute_repository_conf = config(context: store_opts[:context])

        attribute_repository_conf[:module].put(
          resource.id,
          resource.attrs,
          attribute_repository_conf[:run_opts]
        )
      end

      @doc """
      Deletes a `#{__MODULE__}.t()`

      Returns `:ok` if the object was successfuly deleted (whether it existed or not),
      `{:error, any()}` otherwise.
      """

      @spec delete(t(), Keyword.t()) ::
      :ok
      | {:error, %AttributeRepository.WriteError{}}

      def delete(resource, delete_opts \\ [])

      def delete(%__MODULE__{newly_created: false} = resource, delete_opts) do
        attribute_repository_conf = config(context: delete_opts[:context])

        case attribute_repository_conf[:module].delete(
          resource.id,
          attribute_repository_conf[:run_opts]
        ) do
          :ok ->
            :ok

          {:error, %AttributeRepository.Read.NotFoundError{}} ->
            :ok

          {:error, _} = error ->
            error
        end
      end

      def delete(%__MODULE__{newly_created: true}, _delete_opts) do
        :ok
      end

      instance =
        __MODULE__
        |> Module.split()
        |> List.last()
        |> String.downcase()
        |> String.to_atom()

      @doc """
      Returns the configuration to request the attribute repository at runtime
      """

      @spec config(Keyword.t()) :: AttributeRepository.Resource.config()

      def config(_config_opts) do
        case Application.get_env(unquote(opts[:otp_app]), :attribute_repositories)[unquote(instance)] do
          nil ->
            raise "Could not find instance `#{unquote(instance)}` in #{unquote(opts[:otp_app])} "
              <> "application configuration"

            conf ->
              conf
        end
      end

      defoverridable config: 1
    end
  end
end
